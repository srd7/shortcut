/* globals jQuery _ */
(function ($) {
  "use strict";
  ////////////////////////////////////////////////////////
  // Constraints
  ////////////////////////////////////////////////////////
  // Useful keycodes.
  var SHIFT = 16;
  var CTRL = 17;
  var ALT = 18;

  var ESC = 27;

  // Event will be fired when keydown time is longer than KEEP_PRESS_TIME [ms].
  var KEEP_PRESS_TIME = 750;

  // DOM id for this application.
  var DOM_ID = "srd7-keyboard-shortcut-helper";

  ////////////////////////////////////////////////////////
  // Variables
  ////////////////////////////////////////////////////////
  // Current pressing keycodes.
  var currentKeycodes = [];
  // Keycodes that alter table contents.
  var targetKeycodes = [SHIFT, CTRL, ALT];
  // Flag of whether event is running.
  // If table is shown (event  now!) true else false.
  var isEventNow = false;

  ////////////////////////////////////////////////////////
  // Closure Item
  ////////////////////////////////////////////////////////
  /**
   * Detects a keyboard is kept being pressed.
   * This object generated by the immediate function pattern has 5 APIs:
   * 1. startKeyDown : sets cache timestamp and runs callback function
   * 2. endKeyDown   : deletes cache
   * 3. setCallback  : register callback when called key press is continued longer than the setting time
   * 4. isSingleTouch: detects the key touch is single (not kept pressing)
   * 5. resetTime    : delete all cache
   */
  var keepKeydownDetector = (function () {
    var startTimeObj = {};
    var callbackObj = {};

    /**
     * Action when a keyboard starts to press.
     * When a keyboard starts to press, the timestamp will be cached.
     * If timestamp has already cached, cache will not be refreshed.
     *
     * By following function endKeydown, the cache will be abandoned when the keyboard is up.
     *
     * Execute the callback function if defined if the time kept pressing is longer than defined time.
     *
     */
    function startKeydown(e) {
      if(_.isUndefined(startTimeObj[e.keyCode])) {
        // Cache is not defined => set cache.
        startTimeObj[e.keyCode] = e.timeStamp;
      } else {
        // There is cache.
        var callbackItem = callbackObj[e.keyCode];
        // If the callback item (which contains limit and callback function),
        //   check timestamp and execute function if [time key press started] + [wait time] < [current timestamp]
        if(!_.isUndefined(callbackItem) && startTimeObj[e.keyCode] + callbackItem.waitTime < e.timeStamp) {
          callbackItem.callback();
        }
      }
    }

    /**
     * When a keyboard is up, the timestamp cache is abandoned.
     */
    function endKeydown(e) {
      // Delete cache.
      delete startTimeObj[e.keyCode];
    }

    /**
     * Register
     * 1. target key code
     * 2. wait time (if key press is longer than wait, run function)
     * 3. callback function.
     */
    function setCallback(keyCode, waitTime, func) {
      callbackObj[keyCode] = {
        waitTime: waitTime,
        callback: func
      };
    }

    /**
     * Returns the keyboard press is single (not kept pressing).
     */
    function isSingleTouch(e) {
      // If there is not cache, or cache time is current timestamp (cache was set just now),
      //   the key touch will be single.
      return _.isUndefined(startTimeObj[e.keyCode]) || startTimeObj[e.keyCode] === e.timeStamp;
    }

    /**
     * Reset all time cache.
     */
    function resetTime() {
      startTimeObj = {};
    }

    return {
      startKeydown : startKeydown,
      endKeydown   : endKeydown,
      setCallback  : setCallback,
      isSingleTouch: isSingleTouch,
      resetTime    : resetTime
    };
  })();

  // Set up callback function:
  // If Ctrl key is pressed for 750 ms and event is not running, start event.
  keepKeydownDetector.setCallback(CTRL, KEEP_PRESS_TIME, function () {
    if(!isEventNow) {
      runEvent();
    }
  });
  ////////////////////////////////////////////////////////
  // Register Event
  ////////////////////////////////////////////////////////
  // Keydown and Keyup
  document.onkeydown = keydownEvent;
  document.onkeyup = keyupEvent;

  // Reset when the browser window loses the focus.
  $(window).blur(loseFocusEvent);

  ////////////////////////////////////////////////////////
  // Event Implementations
  ////////////////////////////////////////////////////////
  /** Handle keydown */
  function keydownEvent(e) {
    // Notify detector that key down begins.
    keepKeydownDetector.startKeydown(e);
    // Keycode is modified because ignore the difference of full key number and numeric key.
    var keyCode = convertKeyCode(e.keyCode);

    // End event if Esc key is pressed.
    if(keyCode === ESC && isEventNow) {
      endEvent();
    }

    // Preserve pressing key code.
    if(!_.contains(currentKeycodes, keyCode)) {
      // When currentKeycodes has not preserved the key code
      currentKeycodes.push(keyCode);
    }

    if (_.contains(targetKeycodes, keyCode)) {
      if(isEventNow && keepKeydownDetector.isSingleTouch(e)) {
        // If the key code is related to the contents of table, HTML is re-loaded.
        // More over, the event must be running and the key down must be single touch.
        // If the key down is kept pressing, when a user keeps pressing Ctrl key the re-load will be called repeatedly.
        showHtml();
      }
    } else if(_.difference(targetKeycodes, currentKeycodes).length < targetKeycodes.length) {
      // After shortcut event, the table will be hidden.
      if(isEventNow) {
        endEvent();
      }
    }
  }

  /** Handle keyup */
  function keyupEvent(e) {
    // Notify detector.
    keepKeydownDetector.endKeydown(e);
    // See also: keydownEvent
    var keyCode = convertKeyCode(e.keyCode);

    // Remove the key code from currentKeyCodes
    currentKeycodes = _.without(currentKeycodes, keyCode);
    if(isEventNow) {
      // Update table when any key was up, because key up cannot happen repeatedly.
      showHtml();
    }
  }

  /** Handle losing focus */
  function loseFocusEvent() {
    // Reset all caches
    keepKeydownDetector.resetTime();
    currentKeycodes = [];
    // Hide table.
    endEvent();
  }

  /** Start the event */
  function runEvent() {
    isEventNow = true;
    showHtml();
  }
  /** End the event */
  function endEvent() {
    isEventNow = false;
    deleteHtml();
  }

  /** HTML */
  function showHtml() {
    // First, Delete the current HTML.
    deleteHtml();
    // The main <div>.
    // All items from this application will be set in this div.
    var $div = $("<div>").attr("id", DOM_ID);
    // Shortcuts for table.
    // Filtered by (Shift, Ctrl, Alt) are pressed or not.
    var showShortcuts = filterShortcut(
      _.contains(currentKeycodes, SHIFT),
      _.contains(currentKeycodes, CTRL),
      _.contains(currentKeycodes, ALT)
    );
    // Table and related tags.
    var $table = $("<table>");
    var $thead = $("<thead>");
    var $tbody = $("<tbody>");

    // Table header.
    $thead.append(
      $("<tr>").append(
        $("<th>").text(chrome.i18n.getMessage("command")).css("width", "20%")
      ).append(
        $("<th>").text(chrome.i18n.getMessage("command_description")).css("width", "80%")
      )
    );

    // Table body.
    // One shortcut is modified to <tr> and appended to <tbody>.
    _.each(showShortcuts, function (oneShortcut) {
      var $tr = $("<tr>");
      $tr.append(
        $("<th>").text(oneShortcut.command)
      ).append(
        $("<td>").text(oneShortcut.description)
      );
      // Append <tr> to <thead>
      $tbody.append($tr);
    });

    // Append <thead> and <tbody> to <table>
    $table.append($thead).append($tbody);

    // Append <table> to main <div>
    $div.append($table);

    // Show HTML!
    $("body").append($div);
  }

  /** Delete HTML */
  function deleteHtml() {
    $("#" + DOM_ID).remove();
  }

  ////////////////////////////////////////////////////////
  // Logics
  ////////////////////////////////////////////////////////
  // Shortcut list.
  var shortcuts = [
    "ctrl_n",
    "ctrl_t",
    "ctrl_shift_n",
    "ctrl_o",
    "ctrl_click",
    "ctrl_shift_click",
    "ctrl_shift_t",
    "ctrl_1",
    "ctrl_2",
    "ctrl_3",
    "ctrl_4",
    "ctrl_5",
    "ctrl_6",
    "ctrl_7",
    "ctrl_8",
    "ctrl_9",
    "ctrl_tab",
    "ctrl_pagedown",
    "ctrl_shift_tab",
    "ctrl_pageup",
    "alt_f4",
    "ctrl_shift_w",
    "ctrl_w",
    "ctrl_f4",
    "alt_left",
    "shift_backspace",
    "alt_right",
    "alt_home",
    "alt_f",
    "alt_e",
    "f10",
    "ctrl_shift_b",
    "ctrl_h",
    "ctrl_j",
    "ctrl_shift_esc",
    "shift_alt_t",
    "f6",
    "shift_f6",
    "ctrl_shift_j",
    "ctrl_shift_delete",
    "f1",
    "ctrl_shift_m",
    "ctrl_p",
    "ctrl_s",
    "f5",
    "ctrl_r",
    "esc",
    "ctrl_f",
    "ctrl_g",
    "f3",
    "ctrl_shift_g",
    "shift_f3",
    "shift_enter",
    "ctrl_f5",
    "shift_f5",
    "alt_click",
    "ctrl_u",
    "ctrl_d",
    "ctrl_shift_d",
    "f11",
    "ctrl_plus",
    "ctrl_minus",
    "ctrl_0",
    "space",
    "home",
    "end",
    "ctrl_c",
    "ctrl_v",
    "shift_insert",
    "ctrl_shift_v",
    "ctrl_x",
    "shift_delete"
  ];

  /** Filter shortcuts and modified as Array of Object. */
  function filterShortcut(shift, ctrl, alt) {
    // Filter the shortcuts whether pressed and contains Shift, Ctrl and Alt.
    return shortcuts.filter(function (item) {
      return (
        // shift key
        !shift || item.indexOf("shift") > -1
      ) && (
        // ctrl key
        !ctrl || item.indexOf("ctrl") > -1
      ) && (
        // alt key
        !alt || item.indexOf("alt") > -1
      );
    }).map(function (name) {
      // String array is modified to object array.
      return {
        "name"       : name,
        "command"    : nameToCommand(name),
        "description": chrome.i18n.getMessage(name)
      };
    });
  }

  /** Convert ctrl_n -> Ctrl + N */
  function nameToCommand(name) {
    return name.split("_").map(function (key) {
      return key.charAt(0).toUpperCase() + key.substr(1);
    }).join(" + ");
  }

  /** Convert numeric key code to full key code */
  function convertKeyCode(keyCode) {
    if(keyCode >= 96 && keyCode <= 105) {
      return keyCode - 48; // full key "0": 48; numeric key "0": 96;
    } else {
      return keyCode;
    }
  }

})(jQuery);

